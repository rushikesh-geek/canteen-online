/**
 * Slot Management Screen (Admin Only)
 * 
 * Features:
 * - Auto-generate slots for today/tomorrow
 * - Edit slot times and capacity
 * - Delete slots
 * - Add custom slots
 * - View booking status
 */

import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart';

class SlotManagementScreen extends StatefulWidget {
  const SlotManagementScreen({Key? key}) : super(key: key);

  @override
  State<SlotManagementScreen> createState() => _SlotManagementScreenState();
}

class _SlotManagementScreenState extends State<SlotManagementScreen> {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  DateTime selectedDate = DateTime.now();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Slot Management'),
        actions: [
          // Auto-generate slots button
          IconButton(
            icon: const Icon(Icons.auto_awesome),
            tooltip: 'Auto-Generate Slots',
            onPressed: () => _showAutoGenerateDialog(),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _showAddSlotDialog(),
        icon: const Icon(Icons.add),
        label: const Text('Add Slot'),
      ),
      body: Column(
        children: [
          // Date selector
          _buildDateSelector(),
          const Divider(),
          // Slots list
          Expanded(
            child: _buildSlotsList(),
          ),
        ],
      ),
    );
  }

  /// Date selector with prev/next buttons
  Widget _buildDateSelector() {
    final dateStr = DateFormat('EEEE, MMM d, yyyy').format(selectedDate);
    
    return Container(
      padding: const EdgeInsets.all(16),
      color: Colors.blue.shade50,
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          IconButton(
            icon: const Icon(Icons.chevron_left),
            onPressed: () {
              setState(() {
                selectedDate = selectedDate.subtract(const Duration(days: 1));
              });
            },
          ),
          Column(
            children: [
              Text(
                dateStr,
                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              if (_isToday(selectedDate))
                const Text('Today', style: TextStyle(color: Colors.blue)),
              if (_isTomorrow(selectedDate))
                const Text('Tomorrow', style: TextStyle(color: Colors.green)),
            ],
          ),
          IconButton(
            icon: const Icon(Icons.chevron_right),
            onPressed: () {
              setState(() {
                selectedDate = selectedDate.add(const Duration(days: 1));
              });
            },
          ),
        ],
      ),
    );
  }

  /// Build slots list for selected date
  Widget _buildSlotsList() {
    final dateStr = _formatDate(selectedDate);
    
    return StreamBuilder<QuerySnapshot>(
      stream: _firestore
          .collection('orderSlots')
          .where('date', isEqualTo: dateStr)
          .where('isActive', isEqualTo: true)
          .orderBy('startTime')
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          return Center(child: Text('Error: ${snapshot.error}'));
        }

        if (!snapshot.hasData) {
          return const Center(child: CircularProgressIndicator());
        }

        final slots = snapshot.data!.docs;

        if (slots.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.schedule, size: 64, color: Colors.grey),
                const SizedBox(height: 16),
                const Text('No slots for this date'),
                const SizedBox(height: 16),
                ElevatedButton.icon(
                  onPressed: () => _autoGenerateSlots(dateStr),
                  icon: const Icon(Icons.auto_awesome),
                  label: const Text('Auto-Generate Slots'),
                ),
              ],
            ),
          );
        }

        return ListView.builder(
          itemCount: slots.length,
          itemBuilder: (context, index) {
            final doc = slots[index];
            final data = doc.data() as Map<String, dynamic>;
            
            return _buildSlotCard(doc.id, data);
          },
        );
      },
    );
  }

  /// Build individual slot card
  Widget _buildSlotCard(String docId, Map<String, dynamic> data) {
    // Handle both Timestamp and String formats (backward compatibility)
    String startTimeStr = '00:00';
    String endTimeStr = '00:00';
    
    final startField = data['startTime'];
    final endField = data['endTime'];
    
    if (startField is Timestamp) {
      final dt = startField.toDate();
      startTimeStr = '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } else if (startField is String) {
      startTimeStr = startField; // Legacy format
    }
    
    if (endField is Timestamp) {
      final dt = endField.toDate();
      endTimeStr = '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } else if (endField is String) {
      endTimeStr = endField; // Legacy format
    }
    
    final capacity = data['capacity'] as int;
    final bookedCount = data['bookedCount'] ?? 0;
    final isActive = data['isActive'] ?? true;
    final autoGenerated = data['autoGenerated'] ?? false;

    final percentBooked = (bookedCount / capacity * 100).round();
    final isFull = bookedCount >= capacity;

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: isFull
              ? Colors.red
              : bookedCount > 0
                  ? Colors.orange
                  : Colors.green,
          child: Text(
            '$bookedCount',
            style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
          ),
        ),
        title: Text(
          '$startTimeStr - $endTimeStr',
          style: TextStyle(
            fontWeight: FontWeight.bold,
            decoration: isActive ? null : TextDecoration.lineThrough,
          ),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('$bookedCount / $capacity booked ($percentBooked%)'),
            const SizedBox(height: 4),
            LinearProgressIndicator(
              value: bookedCount / capacity,
              backgroundColor: Colors.grey.shade200,
              valueColor: AlwaysStoppedAnimation(
                isFull ? Colors.red : Colors.green,
              ),
            ),
            const SizedBox(height: 4),
            Row(
              children: [
                if (autoGenerated)
                  const Chip(
                    label: Text('Auto', style: TextStyle(fontSize: 10)),
                    backgroundColor: Colors.blue,
                    labelPadding: EdgeInsets.symmetric(horizontal: 4),
                    visualDensity: VisualDensity.compact,
                  ),
                if (!isActive)
                  const Chip(
                    label: Text('Inactive', style: TextStyle(fontSize: 10)),
                    backgroundColor: Colors.grey,
                    labelPadding: EdgeInsets.symmetric(horizontal: 4),
                    visualDensity: VisualDensity.compact,
                  ),
              ],
            ),
          ],
        ),
        trailing: PopupMenuButton<String>(
          onSelected: (value) {
            switch (value) {
              case 'edit':
                _showEditSlotDialog(docId, data);
                break;
              case 'toggle':
                _toggleSlotActive(docId, !isActive);
                break;
              case 'delete':
                _deleteSlot(docId, bookedCount);
                break;
            }
          },
          itemBuilder: (context) => [
            const PopupMenuItem(value: 'edit', child: Text('Edit')),
            PopupMenuItem(
              value: 'toggle',
              child: Text(isActive ? 'Deactivate' : 'Activate'),
            ),
            const PopupMenuItem(value: 'delete', child: Text('Delete')),
          ],
        ),
      ),
    );
  }

  /// Show auto-generate dialog
  Future<void> _showAutoGenerateDialog() async {
    final result = await showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Auto-Generate Slots'),
        content: const Text(
          'Generate default time slots for the selected date?\n\n'
          'This will create slots from 11:00 AM to 4:00 PM with 30 capacity each.\n\n'
          'Existing slots will NOT be overwritten.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, 'cancel'),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, 'generate'),
            child: const Text('Generate'),
          ),
        ],
      ),
    );

    if (result == 'generate') {
      final dateStr = _formatDate(selectedDate);
      await _autoGenerateSlots(dateStr);
    }
  }

  /// Auto-generate slots for a specific date
  /// Only creates slots that don't already exist
  Future<void> _autoGenerateSlots(String dateStr) async {
    try {
      // Check existing slots for this date
      final existing = await _firestore
          .collection('orderSlots')
          .where('date', isEqualTo: dateStr)
          .where('isActive', isEqualTo: true)
          .get();

      final existingTimes = existing.docs
          .map((doc) => '${doc['startTime']}-${doc['endTime']}')
          .toSet();

      // Default slot configuration (hours only)
      final defaultSlots = [
        {'startHour': 11, 'endHour': 12},
        {'startHour': 12, 'endHour': 13},
        {'startHour': 13, 'endHour': 14},
        {'startHour': 14, 'endHour': 15},
        {'startHour': 15, 'endHour': 16},
      ];

      int created = 0;
      final dateTime = DateTime.parse(dateStr); // Parse date string to DateTime

      for (final slot in defaultSlots) {
        // Create DateTime objects for start and end times
        final startDateTime = DateTime(
          dateTime.year,
          dateTime.month,
          dateTime.day,
          slot['startHour']!,
          0, // minute
        );
        final endDateTime = DateTime(
          dateTime.year,
          dateTime.month,
          dateTime.day,
          slot['endHour']!,
          0, // minute
        );

        final key = '${slot['startHour']}-${slot['endHour']}';
        
        // Skip if slot already exists for this time
        if (existingTimes.contains(key)) {
          continue;
        }

        // Create new slot with Timestamp fields (CORRECT DATA MODEL)
        await _firestore.collection('orderSlots').add({
          'date': dateStr,
          'startTime': Timestamp.fromDate(startDateTime), // Timestamp, not String
          'endTime': Timestamp.fromDate(endDateTime),     // Timestamp, not String
          'capacity': 30,
          'bookedCount': 0,
          'isActive': true,
          'autoGenerated': true,
          'createdAt': FieldValue.serverTimestamp(),
        });

        created++;
      }

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Created $created new slot(s)'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e'), backgroundColor: Colors.red),
        );
      }
    }
  }

  /// Show add slot dialog
  Future<void> _showAddSlotDialog() async {
    final startController = TextEditingController(text: '09:00');
    final endController = TextEditingController(text: '10:00');
    final capacityController = TextEditingController(text: '30');
    final formKey = GlobalKey<FormState>();

    await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add Custom Slot'),
        content: Form(
          key: formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextFormField(
                controller: startController,
                decoration: const InputDecoration(
                  labelText: 'Start Time (HH:mm)',
                  hintText: '09:00',
                ),
                validator: (v) => _validateTime(v) ? null : 'Invalid time format',
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: endController,
                decoration: const InputDecoration(
                  labelText: 'End Time (HH:mm)',
                  hintText: '10:00',
                ),
                validator: (v) => _validateTime(v) ? null : 'Invalid time format',
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: capacityController,
                decoration: const InputDecoration(
                  labelText: 'Capacity',
                  hintText: '30',
                ),
                keyboardType: TextInputType.number,
                validator: (v) {
                  final num = int.tryParse(v ?? '');
                  return (num != null && num > 0) ? null : 'Invalid capacity';
                },
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (formKey.currentState!.validate()) {
                await _addSlot(
                  _formatDate(selectedDate),
                  startController.text,
                  endController.text,
                  int.parse(capacityController.text),
                );
                if (context.mounted) Navigator.pop(context);
              }
            },
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }

  /// Add new slot
  Future<void> _addSlot(String date, String start, String end, int capacity) async {
    try {
      // Parse date and time strings to create DateTime objects
      final dateTime = DateTime.parse(date);
      final startParts = start.split(':');
      final endParts = end.split(':');
      
      final startDateTime = DateTime(
        dateTime.year, dateTime.month, dateTime.day,
        int.parse(startParts[0]), int.parse(startParts[1]),
      );
      final endDateTime = DateTime(
        dateTime.year, dateTime.month, dateTime.day,
        int.parse(endParts[0]), int.parse(endParts[1]),
      );

      await _firestore.collection('orderSlots').add({
        'date': date,
        'startTime': Timestamp.fromDate(startDateTime), // Convert to Timestamp
        'endTime': Timestamp.fromDate(endDateTime),     // Convert to Timestamp
        'capacity': capacity,
        'bookedCount': 0,
        'isActive': true,
        'autoGenerated': false, // Admin-created
        'createdAt': FieldValue.serverTimestamp(),
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Slot added successfully')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e'), backgroundColor: Colors.red),
        );
      }
    }
  }

  /// Show edit slot dialog
  Future<void> _showEditSlotDialog(String docId, Map<String, dynamic> data) async {
    // Extract current times - handle both Timestamp and String formats
    String startTimeStr = '09:00';
    String endTimeStr = '10:00';
    
    final startField = data['startTime'];
    final endField = data['endTime'];
    
    if (startField is Timestamp) {
      final dt = startField.toDate();
      startTimeStr = '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } else if (startField is String) {
      startTimeStr = startField;
    }
    
    if (endField is Timestamp) {
      final dt = endField.toDate();
      endTimeStr = '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';
    } else if (endField is String) {
      endTimeStr = endField;
    }
    
    final startController = TextEditingController(text: startTimeStr);
    final endController = TextEditingController(text: endTimeStr);
    final capacityController = TextEditingController(text: data['capacity'].toString());
    final formKey = GlobalKey<FormState>();

    // Get the date from the slot document
    final dateStr = data['date'] as String;

    await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Edit Slot'),
        content: Form(
          key: formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextFormField(
                controller: startController,
                decoration: const InputDecoration(labelText: 'Start Time (HH:mm)'),
                validator: (v) => _validateTime(v) ? null : 'Invalid time',
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: endController,
                decoration: const InputDecoration(labelText: 'End Time (HH:mm)'),
                validator: (v) => _validateTime(v) ? null : 'Invalid time',
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: capacityController,
                decoration: const InputDecoration(labelText: 'Capacity'),
                keyboardType: TextInputType.number,
                validator: (v) {
                  final num = int.tryParse(v ?? '');
                  final bookedCount = data['bookedCount'] ?? 0;
                  if (num == null || num <= 0) return 'Invalid capacity';
                  if (num < bookedCount) return 'Capacity < booked ($bookedCount)';
                  return null;
                },
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (formKey.currentState!.validate()) {
                await _updateSlot(
                  docId,
                  dateStr, // Pass the date
                  startController.text,
                  endController.text,
                  int.parse(capacityController.text),
                );
                if (context.mounted) Navigator.pop(context);
              }
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  /// Update slot
  Future<void> _updateSlot(String docId, String date, String start, String end, int capacity) async {
    try {
      // Parse date and time to create Timestamps
      final dateTime = DateTime.parse(date);
      final startParts = start.split(':');
      final endParts = end.split(':');
      
      final startDateTime = DateTime(
        dateTime.year, dateTime.month, dateTime.day,
        int.parse(startParts[0]), int.parse(startParts[1]),
      );
      final endDateTime = DateTime(
        dateTime.year, dateTime.month, dateTime.day,
        int.parse(endParts[0]), int.parse(endParts[1]),
      );

      await _firestore.collection('orderSlots').doc(docId).update({
        'startTime': Timestamp.fromDate(startDateTime), // Convert to Timestamp
        'endTime': Timestamp.fromDate(endDateTime),     // Convert to Timestamp
        'capacity': capacity,
        'autoGenerated': false, // Mark as manually edited
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Slot updated successfully')),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e'), backgroundColor: Colors.red),
        );
      }
    }
  }

  /// Toggle slot active status
  Future<void> _toggleSlotActive(String docId, bool isActive) async {
    await _firestore.collection('orderSlots').doc(docId).update({
      'isActive': isActive,
    });
  }

  /// Delete slot
  Future<void> _deleteSlot(String docId, int bookedCount) async {
    if (bookedCount > 0) {
      final confirm = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Warning'),
          content: Text(
            'This slot has $bookedCount booking(s). Deleting it may affect orders.\n\n'
            'Are you sure you want to delete?',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context, false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.pop(context, true),
              style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
              child: const Text('Delete'),
            ),
          ],
        ),
      );

      if (confirm != true) return;
    }

    await _firestore.collection('orderSlots').doc(docId).delete();

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Slot deleted')),
      );
    }
  }

  // Helper methods
  String _formatDate(DateTime date) {
    return DateFormat('yyyy-MM-dd').format(date);
  }

  bool _isToday(DateTime date) {
    final now = DateTime.now();
    return date.year == now.year && date.month == now.month && date.day == now.day;
  }

  bool _isTomorrow(DateTime date) {
    final tomorrow = DateTime.now().add(const Duration(days: 1));
    return date.year == tomorrow.year &&
        date.month == tomorrow.month &&
        date.day == tomorrow.day;
  }

  bool _validateTime(String? value) {
    if (value == null || value.isEmpty) return false;
    final regex = RegExp(r'^([01]?[0-9]|2[0-3]):[0-5][0-9]$');
    return regex.hasMatch(value);
  }
}
